const bool BezierCurve = false;

const ivec2 MEMORY_BOUNDARY = ivec2(4, 3);

const ivec2 POSITION = ivec2(0, 0);
const ivec2 UP = ivec2(0, 1);

const ivec2 LOOK = ivec2(0, 2);

const float MIN_DIST = 0.01;
const float MAX_DIST = 50.0;
const int OCTAVES = 8;

const vec2 eps = vec2(0, 1e-3);

#define time (iTime+99.0)
#define pi 3.14159265359


float ti;
float col=1e3;

// ---------------------------tree function---------------------------
float trunkDistanceFunc(vec3 pos, float trunkLgth)
{
    return max(pos.y - trunkLgth, max(-pos.y, length(pos.xz) - 0.1 / (pos.y + 0.7))); // frustum of cone
}

float treeDistancefunc(vec3 pos)
{

    float trunkDist = MAX_DIST;
    float scaleTrunkRadius = 1.0;
    float scaleTrunkLgth = 1.6; // scale down the branch 
    
    // Tangent vectors for the branch local coordinate system.
    vec3 w = normalize(vec3(-0.8 + cos(0.0 / 30.0) *0.01, 1.2, -1.0));
    vec3 u = normalize(cross(w, vec3(0, 1, 0)));
    vec3 v = normalize(cross(u, w));
    mat3 branchMat = mat3(u, v, w);

    int treeLevel = 7;

    float treeSize = 1.0;
    float trunkLgth = 1.0;

    pos /= treeSize;

    int i = 0;
    while (true) {
        trunkDist = min(trunkDist, treeSize * trunkDistanceFunc(pos, trunkLgth) / scaleTrunkRadius);
        pos.xz = abs(pos.xz);
        pos.y -= trunkLgth;
        i += 1;
        if (i == treeLevel) break;
        pos *= branchMat;
        pos *= scaleTrunkLgth;
        scaleTrunkRadius *= scaleTrunkLgth;
    }


    return min(trunkDist,col = max(0., length(pos) - 0.5) / scaleTrunkRadius);
}


/*vec3 nf(vec3 p)
{
    vec2 e = vec2(0,0.005);
    return normalize(vec3(f(p+e.yxx),f(p+e.xyx),f(p+e.xxy)));
}*/

vec3 getTreeNormal(vec3 pos) {
    return normalize(vec3(treeDistancefunc(pos + eps.xyy) - treeDistancefunc(pos - eps.xyy),
                          treeDistancefunc(pos + eps.yxy) - treeDistancefunc(pos - eps.yxy),
                          treeDistancefunc(pos + eps.yyx) - treeDistancefunc(pos - eps.yyx)));
}
// ------------------------------------------------------------------

// -------------------------mountain function------------------------
float noise(in vec2 uv)
{
    return sin(uv.x)+cos(uv.y);
}


float height(vec3 p)
{
    vec2 uv = vec2(p.x + 1.0, p.z + 0.1);
    uv /= 1.5;
    float value = 0.;
    float amplitude = 1.;
    float freq = 0.6;
    
    for (int i = 0; i < OCTAVES; i++)
    {
        value = max(value,value+(.25-abs(noise(uv * freq)-.3) * amplitude));
        amplitude *= .4;
        freq *= 2.;
        
    }
    
    return value*2.0-2.5;
    //return value*2.0;
}

vec3 getMountainNormal(vec3 p, float t)
{
    vec3 eps=vec3(.001 * t, .0, .0);
    vec3 n=vec3(height(p - eps.xyy) - height(p + eps.xyy),
                2. * eps.x,
                height(p - eps.yyx) - height(p + eps.yyx));
  
    return normalize(n);
}



vec3 mountain(vec3 p, vec3 normal, vec3 L, vec3 V, vec3 rd)
{

//water/*
if(p.y < 0.4 - 0.5){
    return vec3(0.1, 0.4, 0.5);
}else if(p.y < 0.45 - 0.5){
    return vec3(0.1, 0.45, 0.55);
}else if(p.y < 0.5 - 0.5){
    return vec3(0.1, 0.5, 0.55);

}
    
    //diffuse
    float N_L = max(dot(normal, L), 0.f);
    
    vec3 col = vec3(0,0,0);

    
    //toon shader
    float intensity = N_L;
    if(N_L > 0.9){
    col = vec3(1.0, 0.5, 0.5);
    }else if(N_L > 0.5){
    col = vec3(0.6, 0.3, 0.3);
    }else if(N_L > 0.25){
    col = vec3(0.4, 0.2, 0.2);
    }else if(N_L > 0.15){
    col = vec3(0.3, 0.2, 0.1);
    }else{
    col = vec3(0.1, 0.1, 0.1);
    }
    
    
   	return col;
}

// ------------------------------------------------------------------

// ---------------------------environment----------------------------
vec3 sunset_sky(vec3 rd, vec3 lightDir){
    vec3 col = vec3(0.99,0.35,0.35);
    col = mix(0.85*vec3(0.9,0.75,0.95),col, pow(1.0-max(rd.y,0.0), 10.0 ) );
    return col;
}

vec3 sun(vec3 rd, vec3 lightDir){
   float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);
    vec3 col = 0.2*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );
	col += 0.3*vec3(1.0,0.8,0.6)*pow( sundot,256.0 );
	col += 0.5*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );

    return col;
}

vec3 horizon(vec3 col, vec3 rd){
    vec3 new_col = mix(col, 0.7*vec3(0.75,0.65,0.8), pow( 1.0-max(rd.y,0.0), 8.0 ) );
    return new_col;

}

vec3 fog(vec3 col, float t){
    float coef = 1.0-exp(-pow(30. * t/250.,1.5) );
    vec3 fog = 0.7*vec3(0.75,0.65,0.8);
    vec3 newcol = mix( col, fog, coef);
    return newcol;

}

// ------------------------------------------------------------------





float sphere(vec3 pos, float radius, vec3 center) {
    return length(pos - center) - radius;
}


float rayMarch(in vec3 ro, in vec3 rd, out bool hitTree)
{
    float dist;
    float t = MIN_DIST;
	for( int i = 0; i < 300; i++ )
	{
        vec3 pos = ro + t * rd;
        dist = treeDistancefunc(pos);
        if (dist < 0.001) {
            hitTree = true;
            break;
        }
		float h = pos.y - height(pos);
		if(t > MAX_DIST) 
            break;
		t += min(dist, 0.2 * h);
	}

	return t;
}



void solveEquation(mat4 coeCalculate, vec4 pos, out vec4 coe) {
    coe = coeCalculate * pos;
}

// -----------------------------camera-----------------------------
mat3 camera_matrix(vec3 cameraPos, vec3 lookAtPoint) {
    vec3 look = lookAtPoint - cameraPos;
    vec3 up = vec3 (0.f,1.f,0.f);
    
    vec3 w = normalize(-look);
    vec3 v = normalize(up - dot(up,w)*w);
    vec3 u = cross(v, w);
	
	return mat3(u,v,w);
}


mat3 calculateCameraMatrix(vec3 look, vec3 up) {
    vec3 w = normalize(-look);
    vec3 v = normalize(up - dot(up,w)*w);
    vec3 u = cross(v, w);
	
	return mat3(u,v,w);
}

// Calculate the current camera position
void animateCamera(float t, out vec3 cameraPos) {
    t = mod(t, 10.0);
    mat4 coeCalculate = mat4(-1.0,  3.0, -3.0,  1.0,
                              3.0, -6.0,  3.0,  0.0,
                             -3.0,  3.0,  0.0,  0.0,
                              1.0,  0.0,  0.0,  0.0);
    // The position of the ith point is actually (posX[i], posY[i], posZ[i])
    vec4 posX;  // X dimensions of 4 points
    vec4 posY;
    vec4 posZ;
    
    // Different routines based on time
    if(t < 5.0) {
        t /= 5.0;
        posX = vec4( 0.0, 10.0, -10.0,  0.0);
        posY = vec4( 3.0,  2.0,   3.0,  2.0);
        posZ = vec4( 0.0,  5.0,  10.0, 15.0);
    } else {
        t = (t - 5.0) / 5.0;
        posX = vec4( 0.0, 10.0, -10.0,  0.0);
        posY = vec4( 2.0,  3.0,   3.0,  3.0);
        posZ = vec4(15.0, 10.0,   5.0,  0.0);
    }
    
    vec4 coeX;
    vec4 coeY;
    vec4 coeZ;
    solveEquation(coeCalculate, posX, coeX);
    solveEquation(coeCalculate, posY, coeY);
    solveEquation(coeCalculate, posZ, coeZ);
    
    // Get the coefficients for BÃ©zier curve
    vec3 a = vec3(coeX[0], coeY[0], coeZ[0]);
    vec3 b = vec3(coeX[1], coeY[1], coeZ[1]);
    vec3 c = vec3(coeX[2], coeY[2], coeZ[2]);
    vec3 d = vec3(coeX[3], coeY[3], coeZ[3]);
    
    // Calculate the current position
    cameraPos = a * t * t * t + b * t * t + c * t + d;
}
// ----------------------------------------------------------------

vec4 load(ivec2 dataPosition) {
    return texelFetch(iChannel1, ivec2(dataPosition), 0);
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    //vec2 uv = fragCoord/iResolution.xy;
    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;  // [-0.5, 0.5]
    vec3 lightDir = normalize(vec3(-1., .2, -1.));
    vec3 sunpos = normalize(vec3(-1., 1.0 * abs(sin(0.1*iTime))-0.8, -1.));
    
    
    vec3 cameraPos;
    mat3 view_matrix;
    
    if(BezierCurve) {
        //camera data
        cameraPos = vec3(5., 2., 5.);
        vec3 lookAtPoint = vec3(-1., 2, 4.);
        animateCamera(0.3*iTime, cameraPos);
        
        view_matrix = camera_matrix(cameraPos, lookAtPoint);
    } else {
        //camera data
        cameraPos = load(POSITION).xyz;
        vec3 look = load(LOOK).xyz;
        vec3 up = load(UP).xyz;
        
        view_matrix = calculateCameraMatrix(look, up);
    }

    //ray
    vec3 ro = cameraPos;
    vec3 rd = normalize(view_matrix * vec3(uv.xy, -1.0));
    
    bool hitTree = false;
    //ray march
    float t = rayMarch(ro, rd, hitTree);
    
    vec3 color = vec3(0.f);
    float dist = MAX_DIST;
    
   
    if(t < MAX_DIST){
        //if we hit a mountain
        vec3 p = ro + rd * t;
        
        dist = distance(p, ro) / 5.0;
        
        if (hitTree) {
            color = vec3(.5,.45,.4) / 5.5;
            if (col < 2e-3) color = vec3(.9, .09, .07);
            vec3 normal = getTreeNormal(p);
            vec3 diffuseColor = color;
            float lambertain = max(dot(lightDir, normal), 0.0);
            color += lambertain * diffuseColor;
            
        } else {
            vec3 normal = getMountainNormal(p,t);
            vec3 viewDir = normalize(ro - p);
            color = mountain(p, normal, lightDir, viewDir, rd);
            
        }
        color = fog(color, t);
    } else {
        color += sunset_sky(rd, sunpos);
        color += sun(rd, sunpos);
        color = horizon(color, rd);
    }
    //color = pow(clamp(color, 0., 1.), vec3(.45)); 

    fragColor = vec4(vec3(color), dist);

}
